# AI Agent Platform 기술 설명서 (비전문가용)

**작성일**: 2025년 8월 20일  
**대상**: 기술적 배경이 없는 이해관계자

## 🎯 프로젝트 개요

AI Agent Platform은 사용자가 인공지능 에이전트를 만들고 관리할 수 있는 웹 애플리케이션입니다. 사용자는 웹 브라우저에서 에이전트를 생성하고, 대화하며, 관리할 수 있습니다.

**최종 결과물**: http://34.64.193.42/static/dashboard.html (웹 대시보드)

## 🏗️ 사용된 주요 기술과 역할

### 1. Google Cloud Platform (GCP)
**역할**: 전체 시스템이 실행되는 클라우드 서버 환경
**구체적 기능**:
- 전 세계 어디서든 접속 가능한 서버 제공
- 사용량에 따라 자동으로 서버 용량 조절
- 99.9% 가동률 보장

**왜 선택했나**: 안정성이 높고, 사용한 만큼만 비용을 지불하며, 자동 확장 기능이 우수함

### 2. Kubernetes (GKE Autopilot)
**역할**: 애플리케이션을 자동으로 관리하는 시스템
**구체적 기능**:
- 서버에 문제가 생기면 자동으로 복구
- 사용자가 많아지면 자동으로 서버 추가
- 사용자가 적어지면 자동으로 서버 감소 (비용 절약)

**왜 필요한가**: 24시간 무중단 서비스를 위해 필요. 사람이 직접 관리하지 않아도 시스템이 알아서 운영됨

### 3. Docker
**역할**: 애플리케이션을 표준화된 박스에 포장하는 기술
**구체적 기능**:
- 개발 환경과 실제 서비스 환경을 동일하게 만듦
- 어떤 서버에서도 동일하게 실행 보장
- 배포 과정 단순화

**왜 필요한가**: "내 컴퓨터에서는 잘 되는데 서버에서는 안 된다"는 문제를 방지

### 4. Firestore (데이터베이스)
**역할**: 사용자 데이터와 에이전트 정보를 저장하는 창고
**구체적 기능**:
- 사용자가 만든 에이전트 정보 저장
- 대화 내역 저장
- 실시간 데이터 동기화

**왜 선택했나**: Google이 관리하는 안전한 데이터베이스로, 별도 관리가 필요 없음

### 5. FastAPI (웹 애플리케이션 프레임워크)
**역할**: 웹 브라우저와 서버 간의 통신을 처리하는 프로그램
**구체적 기능**:
- 사용자의 요청(에이전트 생성, 수정, 삭제)을 받아서 처리
- 데이터베이스에서 정보를 가져와서 웹 브라우저에 전달
- 실시간 채팅 기능 제공

**왜 선택했나**: 빠르고 안정적이며, 자동으로 API 문서를 생성해줌

### 6. WebSocket
**역할**: 실시간 양방향 통신을 가능하게 하는 기술
**구체적 기능**:
- 사용자와 AI 에이전트 간의 실시간 대화
- 페이지를 새로고침하지 않아도 즉시 응답 표시

**왜 필요한가**: 채팅 같은 실시간 상호작용을 위해 필요

### 7. LoadBalancer
**역할**: 여러 서버로 사용자 요청을 분산시키는 교통정리 시스템
**구체적 기능**:
- 사용자 요청을 여러 서버에 고르게 분배
- 특정 서버에 문제가 생겨도 다른 서버로 자동 연결
- 외부에서 접속 가능한 고정 IP 주소 제공

**왜 필요한가**: 많은 사용자가 동시에 접속해도 서비스가 느려지지 않도록 함

### 8. Secret Manager
**역할**: 중요한 정보(API 키, 비밀번호)를 안전하게 보관하는 금고
**구체적 기능**:
- Anthropic API 키 등 민감한 정보 암호화 저장
- 애플리케이션에서만 접근 가능하도록 권한 제어

**왜 필요한가**: 해킹당해도 중요한 정보가 노출되지 않도록 보호

## 🔧 아키텍처 변경 과정

### 기존 방식의 문제점
**Docker-in-Docker 방식**을 사용했었음:
- 컨테이너 안에서 또 다른 컨테이너를 실행하는 방식
- 보안상 위험하고 관리가 복잡함
- Google Cloud의 보안 정책에 위배됨

### 새로운 방식으로 개선
**Kubernetes-Native 방식**으로 변경:
- 컨테이너를 중첩하지 않고 직접 실행
- 보안성 향상 및 관리 단순화
- Google Cloud 정책에 완전 준수

## 🐛 주요 문제와 해결 과정

### 문제 1: 보안 정책 위반
**상황**: Google Cloud에서 특권 컨테이너 사용을 차단
```
"Autopilot doesn't support privileged pods"
```
**원인**: 보안상 위험한 설정을 사용했기 때문
**해결**: 특권이 필요 없는 방식으로 애플리케이션 재설계

### 문제 2: 컴퓨터 아키텍처 불일치
**상황**: 개발 컴퓨터(Apple M1)와 서버(Intel)의 CPU 아키텍처가 다름
**원인**: ARM64용으로 만든 프로그램을 AMD64 서버에서 실행하려 했음
**해결**: 서버용 아키텍처로 다시 빌드하여 배포

### 문제 3: 데이터베이스 접근 권한 문제
**상황**: 애플리케이션이 Firestore 데이터베이스에 접근할 수 없음
```
"403 Missing or insufficient permissions"
```
**원인**: Kubernetes에서 Google Cloud 서비스에 접근할 권한이 제대로 설정되지 않음
**해결**: Workload Identity 설정으로 안전한 권한 부여

### 문제 4: 네트워크 접근 문제
**상황**: 외부에서 웹 애플리케이션에 접속할 수 없음
**원인**: 서비스가 내부 네트워크로만 설정되어 있음
**해결**: LoadBalancer 타입으로 변경하여 외부 접근 허용

## 💰 비용 구조

### 월간 예상 비용 (100명 이하 사용자 기준)
- **서버 운영비 (GKE)**: $25-50
- **네트워크 비용 (LoadBalancer)**: $18
- **데이터베이스 (Firestore)**: $1-5
- **이미지 저장소**: $1

**총 예상 비용**: $45-75/월

### 비용 최적화 전략
1. **자동 스케일링**: 사용자가 적을 때 서버 수 자동 감소
2. **리소스 제한**: 필요 이상의 서버 자원 사용 방지
3. **효율적인 데이터베이스 사용**: 불필요한 데이터 쿼리 최소화

## 🔒 보안 측면

### 적용된 보안 조치
1. **API 키 암호화**: Secret Manager로 중요 정보 보호
2. **네트워크 격리**: 내부 통신과 외부 접근 경로 분리
3. **권한 최소화**: 필요한 최소한의 권한만 부여
4. **자동 보안 업데이트**: Google Cloud에서 자동으로 보안 패치 적용

### 데이터 보호
- 모든 데이터는 Google Cloud의 보안 기준에 따라 암호화
- 사용자별 데이터 격리로 다른 사용자 정보 접근 불가
- 정기적인 백업으로 데이터 손실 방지

## 📊 성능 특징

### 현재 설정
- **동시 사용자**: 최대 100명 지원
- **응답 시간**: 평균 200ms 이하
- **가용성**: 99.9% (연간 8.7시간 이하 중단)
- **자동 복구**: 서버 장애 시 30초 내 자동 복구

### 확장 가능성
- 사용자 증가 시 자동으로 서버 추가
- 최대 1000명까지 확장 가능 (추가 설정 시)
- 전 세계 여러 지역으로 서비스 확장 가능

## 🚀 향후 개선 방향

### 단기 계획 (1-3개월)
1. **도메인 연결**: 기억하기 쉬운 웹 주소 설정
2. **HTTPS 적용**: 더 안전한 암호화 통신
3. **모니터링 강화**: 시스템 상태 실시간 감시

### 중기 계획 (3-6개월)
1. **Claude Code CLI 개선**: 더 많은 기능 지원
2. **파일 업로드**: 사용자 파일 처리 기능
3. **협업 기능**: 여러 사용자가 함께 작업할 수 있는 기능

### 장기 계획 (6개월 이상)
1. **AI 모델 다양화**: Anthropic 외 다른 AI 모델 지원
2. **모바일 앱**: 스마트폰에서도 사용 가능한 앱 개발
3. **기업용 기능**: 팀 관리, 권한 설정 등 기업 필요 기능

## 🎭 사용자 시나리오별 기술 상호작용

### 시나리오 1: 새 사용자가 첫 번째 에이전트를 만드는 과정

**1단계: 웹사이트 접속**
- 사용자가 브라우저에 `http://34.64.193.42/static/dashboard.html` 입력
- **LoadBalancer**가 사용자 요청을 받아서 가장 적절한 서버로 연결
- **Kubernetes**가 현재 실행 중인 Pod(서버 인스턴스) 중 하나를 선택
- **FastAPI**가 대시보드 HTML 파일을 브라우저에 전송

**2단계: 게스트 세션 생성**
- 브라우저에서 JavaScript가 자동으로 `/api/auth/guest` API 호출
- **FastAPI**가 요청을 받고 고유한 세션 ID 생성
- **Firestore**에 임시 사용자 정보 저장
- 브라우저에 세션 정보 저장 (로컬 스토리지)

**3단계: 에이전트 생성 버튼 클릭**
- 사용자가 "새 에이전트 만들기" 버튼 클릭
- 브라우저가 `/api/agents` API에 POST 요청 전송
- **LoadBalancer** → **Kubernetes Pod** → **FastAPI** 순서로 요청 전달
- **FastAPI**가 **Secret Manager**에서 필요한 권한 확인
- **Firestore**에 새 에이전트 정보 저장
- 생성 완료 응답을 브라우저에 전송

**4단계: 실시간 대화 시작**
- 사용자가 에이전트와 채팅 시작
- 브라우저가 **WebSocket** 연결 요청
- **FastAPI**가 WebSocket 연결 수락
- 사용자 메시지가 실시간으로 서버에 전달
- **Firestore**에 대화 내역 즉시 저장
- AI 응답이 **WebSocket**을 통해 즉시 브라우저에 표시

### 시나리오 2: 기존 사용자가 에이전트 목록을 조회하는 과정

**1단계: 대시보드 로딩**
- 사용자가 웹사이트에 재접속
- 브라우저가 저장된 세션 정보로 자동 로그인
- **FastAPI**가 `/api/auth/validate` API로 세션 유효성 확인

**2단계: 에이전트 목록 요청**
- 대시보드가 로딩되면서 `/api/agents` API 자동 호출
- **LoadBalancer**가 요청을 적절한 서버로 분배
- **Kubernetes**가 현재 가장 여유로운 Pod 선택
- **FastAPI**가 **Workload Identity**로 **Firestore** 접근 권한 확인

**3단계: 데이터베이스 조회**
- **FastAPI**가 **Firestore**에서 해당 사용자의 에이전트 목록 쿼리
- **Firestore**가 암호화된 데이터를 복호화하여 반환
- **FastAPI**가 JSON 형태로 데이터 가공
- 브라우저에 에이전트 목록 전송 및 화면 업데이트

### 시나리오 3: 시스템이 사용자 급증에 자동 대응하는 과정

**1단계: 트래픽 증가 감지**
- 동시 접속자가 평소보다 3배 증가
- **Kubernetes**의 **HPA**(Horizontal Pod Autoscaler)가 CPU 사용률 80% 초과 감지
- **LoadBalancer**가 응답 시간 지연 모니터링

**2단계: 자동 스케일링 실행**
- **Kubernetes**가 새로운 Pod 생성 명령 실행
- **GCP**가 추가 서버 리소스 자동 할당
- **Docker** 이미지가 새 Pod에 자동 배포
- **Secret Manager**에서 새 Pod에 필요한 API 키 자동 주입

**3단계: 트래픽 분산**
- **LoadBalancer**가 새로 생성된 Pod도 포함하여 트래픽 분산
- 모든 Pod가 동일한 **Firestore** 데이터베이스 공유로 일관성 보장
- 사용자는 서버 증설 과정을 전혀 느끼지 못함

**4단계: 트래픽 감소 시 자동 축소**
- 사용자 수가 다시 감소하면 **HPA**가 불필요한 Pod 자동 제거
- 비용 절약을 위해 최소 1개 Pod만 유지
- 모든 과정이 사용자 서비스 중단 없이 진행

### 시나리오 4: 서버 장애 발생 시 자동 복구 과정

**1단계: 장애 감지**
- 특정 Pod에서 메모리 부족으로 애플리케이션 크래시 발생
- **Kubernetes**의 Health Check가 3회 연속 실패 감지
- **LoadBalancer**가 해당 Pod로의 트래픽 차단

**2단계: 자동 복구 실행**
- **Kubernetes**가 문제 Pod 자동 재시작
- 재시작 실패 시 새로운 Pod 자동 생성
- **Secret Manager**에서 필요한 권한 자동 재설정
- **Workload Identity**로 **Firestore** 접근 권한 자동 복구

**3단계: 서비스 정상화**
- 새 Pod가 정상 상태가 되면 **LoadBalancer**가 트래픽 재분배
- 사용자는 최대 30초간의 일시적 지연만 경험
- **Firestore**에 저장된 모든 데이터는 손실 없이 보존
- 진행 중이던 대화는 **WebSocket** 재연결로 자동 복구

### 시나리오 5: 보안 위협 차단 과정

**1단계: 의심스러운 접근 감지**
- 특정 IP에서 비정상적으로 많은 API 요청 발생
- **LoadBalancer**가 초당 요청 수 임계값 초과 감지
- **GCP**의 자동 DDoS 보호 시스템 활성화

**2단계: 자동 차단 및 보호**
- 의심스러운 IP 주소 자동 차단
- **Secret Manager**가 API 키 무단 사용 시도 감지 및 차단
- **Firestore**의 권한 시스템이 무권한 데이터 접근 차단
- **Workload Identity**가 서비스 간 무권한 통신 차단

**3단계: 정상 사용자 보호**
- 정상 사용자는 영향 없이 계속 서비스 이용
- **Kubernetes**가 추가 리소스 할당으로 성능 저하 방지
- 모든 보안 이벤트는 **GCP**의 로그 시스템에 자동 기록

## 🔄 기술 간 상호작용 흐름도

### 일반적인 API 요청 처리 흐름
```
사용자 브라우저 
    ↓ HTTP 요청
LoadBalancer (트래픽 분산)
    ↓ 최적 Pod 선택
Kubernetes Pod 
    ↓ 애플리케이션 실행
FastAPI (요청 처리)
    ↓ 권한 확인
Secret Manager & Workload Identity
    ↓ 데이터 처리
Firestore (데이터 저장/조회)
    ↓ 응답 생성
FastAPI (JSON 응답)
    ↓ HTTP 응답
LoadBalancer
    ↓ 최종 응답
사용자 브라우저 (화면 업데이트)
```

### 실시간 채팅 처리 흐름
```
사용자 입력
    ↓ WebSocket
FastAPI (실시간 처리)
    ↓ 병렬 처리
├─ Firestore (대화 저장)
├─ AI 처리 (Claude API)
└─ 사용자 세션 관리
    ↓ 실시간 응답
WebSocket
    ↓ 즉시 표시
사용자 화면
```

## 📞 관리 및 운영

### 일상 관리
- **자동 운영**: 대부분의 관리 작업이 자동화됨
- **모니터링**: Google Cloud에서 시스템 상태 자동 감시
- **백업**: 데이터 자동 백업 (매일)

### 장애 대응
- **자동 복구**: 대부분의 문제는 자동으로 해결
- **알림 시스템**: 심각한 문제 발생 시 즉시 알림
- **수동 개입**: 복잡한 문제는 개발팀이 직접 해결

### 사용량 추적
- **실시간 모니터링**: 동시 접속자, 서버 사용률 등
- **비용 추적**: 월간 사용량과 비용 자동 계산
- **성능 분석**: 응답 시간, 에러율 등 지속적 모니터링

---

**요약**: AI Agent Platform은 최신 클라우드 기술을 활용하여 안정적이고 확장 가능하며 비용 효율적인 서비스를 제공합니다. 각 기술이 유기적으로 연동되어 사용자는 복잡한 기술 인프라를 의식하지 않고도 원활한 서비스를 이용할 수 있습니다.