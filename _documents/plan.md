## 🎯 서비스 컨셉: "AI 에이전트 빌더"

사용자가 자연어 대화만으로 자신만의 자동화 에이전트(AI 비서)를 만들고, 스케줄링하며, 관리할 수 있는 **구독형 웹 서비스(SaaS)**입니다. 코딩 지식이 없는 전문가, 마케터, 1인 기업가, 연구원 등이 주 타겟입니다.



### **✨ 이 서비스가 제공해야 할 핵심 가치**

1.  **접근성 (Accessibility):** 복잡한 Python 환경 설정, 라이브러리 설치, 코드 디버깅 과정을 완전히 제거하고, 자연어라는 가장 직관적인 인터페이스만 남깁니다.
2.  **확장성 (Scalability):** PyPI의 50만 개가 넘는 패키지를 무한한 기능의 '앱 스토어'처럼 활용하여, 사용자의 상상력을 기술적 한계 없이 구현해줍니다.
3.  **자동화 (Automation):** 한 번 만들어진 에이전트는 스케줄에 따라 자동으로 실행되어, 사용자의 반복적인 업무를 완벽하게 대신 수행합니다.

---

## 🚀 서비스의 주요 기능 (UI/UX 관점)

사용자의 아이디어를 바탕으로 서비스의 화면과 기능을 구체화하면 다음과 같은 모습이 될 것입니다.

### **1. 에이전트 생성 스튜디오 (Agent Creation Studio)**
* **대화형 인터페이스:** "매일 아침 9시에 경쟁사 웹사이트 3곳의 신제품 정보를 긁어와서, 주요 키워드를 분석하고, 그 결과를 슬랙으로 보고해 줘" 와 같은 자연어 명령을 입력하는 채팅창.
* **실시간 피드백:** Claude Code가 사용자의 말을 해석하며 어떤 패키지를 설치하고, 어떤 순서로 작업을 진행할지 실시간으로 보여줍니다. (`requests 설치 중...`, `pandas로 데이터 분석 중...`)
* **토큰 사용량 표시:** 에이전트 생성 및 실행 과정에서 소모되는 LLM 토큰 양을 실시간으로 표시하여 사용량을 투명하게 관리합니다.
* **보안 경고:** 파일 시스템 접근이나 외부 API 키를 요구하는 등 민감한 작업을 수행하기 전에 사용자에게 명확하게 허락을 구하는 절차.

### **2. 에이전트 대시보드 (Agent Dashboard)**
* **내 에이전트 목록:** 내가 만든 모든 에이전트(예: '경쟁사 분석 봇', '유튜브 콘텐츠 자동 업로더')가 카드 형태로 나열됩니다.
* **상태 관리:** 각 에이전트를 `활성화/비활성화`하고, `즉시 실행`하거나 `실행 예약`을 설정할 수 있습니다.
* **실행 로그:** 에이전트가 언제, 어떤 작업을 수행했고, 성공했는지 실패했는지 기록을 확인할 수 있어 투명성을 보장합니다.
* **토큰 사용량 모니터링:** 각 에이전트별 누적 토큰 사용량과 실행별 토큰 소모량을 확인할 수 있습니다.

---

## ⚙️ 기술적 과제 및 해결 방안

이 서비스를 구현하기 위해서는 몇 가지 중요한 기술적 허들을 넘어야 합니다.

* **보안 (Security):** 사용자가 임의의 코드를 실행시키는 것은 가장 큰 문제입니다.
    * **해결책:** **가상화 샌드박스** 기술(예: Docker 컨테이너, gVisor, Firecracker)을 사용하여 각 사용자의 실행 환경을 완벽하게 격리해야 합니다. 파일 시스템 접근, 네트워크 포트 사용 등을 엄격히 제한하고 제어해야 합니다.
* **자원 관리 (Resource Management):** 특정 에이전트가 과도한 CPU나 메모리를 사용하여 다른 사용자에게 영향을 주는 것을 막아야 합니다.
    * **해결책:** **컨테이너 오케스트레이션**(예: Kubernetes)을 도입하여 각 에이전트의 자원 사용량을 제한하고, 필요에 따라 자원을 동적으로 할당/회수해야 합니다.
* **상태 유지 (State Persistence):** "어제 분석했던 데이터에 이어서 오늘 데이터를 추가 분석해 줘"와 같은 연속적인 작업을 처리하려면 에이전트가 이전 작업의 결과(상태)를 기억해야 합니다.
    * **해결책:** 각 에이전트별로 **전용 클라우드 스토리지**를 할당하여 작업 결과물이나 필요한 파일을 저장하고, 다음 실행 시 불러올 수 있도록 설계해야 합니다.


-----

## 🏛️ 최종 아키텍처: The Modern Serverless Stack

각 서비스가 가장 잘하는 역할에 집중하도록 전문화하여 시너지를 극대화하는 구성입니다.

| 역할 구분 | 추천 GCP 서비스 | 담당 업무 |
| :--- | :--- | :--- |
| **🧠 컴퓨팅 엔진** | **Cloud Run** | • 웹/API 서버 <br>• 사용자 코드의 격리 및 실행 |
| **🗂️ 메타데이터 관리** | **Firestore** | • 사용자 정보, 에이전트 설정, 작업 로그 <br>• **Cloud Storage 파일 경로** 등 구조화된 데이터 관리 <br>• **토큰 사용량 추적** 및 대화 히스토리 저장 |
| **📦 대용량 파일 저장소** | **Cloud Storage** | • 에이전트가 생성한 **이미지, 영상, CSV, PDF** 등 <br>• 모든 종류의 비정형 데이터 파일 보관 |
| **⏰ 자동화 트리거** | **Cloud Scheduler** | • 지정된 시간에 Cloud Run을 호출하여 <br>• 예약된 에이전트 작업 실행 |

-----

### \#\# ✨ 서비스 간 시너지 워크플로우 예시

"유튜브 영상의 자막을 추출해 영상에 합성한 후, 결과물을 제공해 줘"라는 요청 처리 과정

1.  **요청 접수 (Cloud Run):** 사용자가 웹 인터페이스를 통해 요청을 보냅니다. API 서버 역할을 하는 **Cloud Run**이 이 요청을 받습니다.

2.  **작업 기록 생성 (Firestore):** **Cloud Run**은 **Firestore**에 `작업 ID: 123, 상태: '처리중', 요청자: 'user_A'` 와 같은 작업 문서를 생성합니다.

3.  **핵심 작업 실행 (Cloud Run):** 백그라운드에서 코드 실행 역할을 하는 또 다른 **Cloud Run** 인스턴스가 호출됩니다. 이 인스턴스는 `yt-dlp`, `moviepy` 등의 패키지를 사용하여 영상 다운로드, 자막 추출, 영상 편집 등 무거운 작업을 수행합니다.

4.  **결과물 저장 (Cloud Storage):** 작업이 완료되면, 최종적으로 생성된 자막이 입혀진 영상 파일(`final_video_123.mp4`)을 **Cloud Storage** 버킷에 업로드합니다.

5.  **상태 업데이트 (Firestore):** 파일 업로드가 끝나면, **Cloud Run**은 다시 **Firestore**의 작업 문서를 업데이트합니다. `상태: '완료', 결과물_경로: 'gs://my-bucket/final_video_123.mp4'`

6.  **결과 제공 (Cloud Run):** 사용자의 웹 브라우저는 **Firestore**의 상태 변경을 감지하고, **Cloud Storage**에 저장된 결과물에 대한 다운로드 링크를 사용자에게 보여줍니다.

-----

### \#\# 💎 최종안의 핵심 가치

  * **역할 분리를 통한 전문성:** 빠른 데이터베이스 쿼리가 필요한 메타데이터는 **Firestore**가, 저렴하고 안정적인 대용량 파일 저장은 **Cloud Storage**가 전담하여 각 서비스의 성능을 최대로 활용합니다.
  * **비용 최적화:** 대용량 파일을 Firestore에 저장하면 비용이 매우 비싸지만, Cloud Storage를 사용하면 훨씬 저렴한 비용으로 데이터를 보관할 수 있습니다.
  * **완벽한 확장성:** 서비스의 어떤 부분이 바빠지더라도(예: 파일 저장 요청 폭주, 코드 실행 요청 폭주) 각 서비스가 독립적으로 자동 확장되므로 병목 현상 없이 안정적인 운영이 가능합니다.