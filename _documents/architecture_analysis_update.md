# AI 에이전트 플랫폼 - 아키텍처 분석 및 업데이트

**작성일**: 2025년 8월 19일  
**분석 목적**: 현재 컨테이너 사용 패턴 점검 및 단순화 방향 제시

---

## 📊 현재 아키텍처 분석

### 🐳 컨테이너 생성 패턴 현황

#### 현재 구조
```python
# main.py:34-40
class UserWorkspace:
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.container = None
        self.container_name = f"workspace-{user_id}"  # 사용자당 1개 컨테이너
```

#### 실제 동작 방식
1. **WebSocket 연결 시**: 사용자별 컨테이너 1개 생성/재사용
2. **에이전트 생성 시**: **새로운 컨테이너 생성 없음** - 기존 사용자 컨테이너 재사용
3. **컨테이너 범위**: 사용자 단위 (에이전트 단위 아님)

---

## 🔍 컨테이너 사용 패턴 분석

### ✅ 현재 패턴: "1인 1컨테이너"

```
사용자 A → 컨테이너 A → 에이전트 1, 2, 3, 4...
사용자 B → 컨테이너 B → 에이전트 5, 6, 7...
사용자 C → 컨테이너 C → 에이전트 8, 9...
```

**장점:**
- ✅ **단순한 구조**: 사용자당 하나의 환경
- ✅ **리소스 효율적**: 에이전트마다 컨테이너를 만들지 않음
- ✅ **관리 용이**: 사용자별 데이터 격리
- ✅ **빠른 에이전트 생성**: 컨테이너 재사용으로 즉시 시작

**단점:**
- ⚠️ **에이전트 간 격리 부족**: 같은 사용자의 에이전트들이 파일시스템 공유
- ⚠️ **리소스 제한 공유**: 1GB 메모리를 모든 에이전트가 나눠 사용

### ❌ 대안: "1에이전트 1컨테이너" (권장하지 않음)

```
에이전트 1 → 컨테이너 1
에이전트 2 → 컨테이너 2  
에이전트 3 → 컨테이너 3
...
```

**단점:**
- ❌ **리소스 낭비**: 컨테이너마다 기본 500MB+ 메모리 사용
- ❌ **시작 시간 증가**: 에이전트 생성마다 3-5초 대기
- ❌ **복잡성 증가**: 컨테이너 생명주기 관리 복잡
- ❌ **운영 부담**: 수십/수백 개 컨테이너 관리

---

## 💡 권장사항: 현재 구조 유지

### 🎯 핵심 원칙: "적은 코드, 단순한 구조"

현재의 **"1인 1컨테이너"** 방식이 요구사항에 최적화되어 있음:

1. **단순성**: 컨테이너 관리 로직 최소화
2. **효율성**: 리소스 사용량 예측 가능
3. **응답성**: 에이전트 즉시 생성 가능
4. **확장성**: 사용자 증가에 선형적으로 대응

### 📋 구체적 개선 방안

#### 1. 에이전트별 작업 디렉토리 분리
```python
# 현재: /workspace (공유)
# 개선: /workspace/agent-{agent_id}

def get_agent_workdir(self, agent_id: str) -> str:
    return f"/workspace/agent-{agent_id}"
```

#### 2. 리소스 모니터링 강화
```python
def check_container_resources(self):
    """컨테이너 리소스 사용량 체크"""
    stats = self.container.stats(stream=False)
    memory_usage = stats['memory_stats']['usage']
    if memory_usage > 800_000_000:  # 800MB 초과시
        logger.warning(f"High memory usage for user {self.user_id}")
```

#### 3. 에이전트별 환경 변수 격리
```python
def set_agent_env(self, agent_id: str, env_vars: dict):
    """에이전트별 환경 설정"""
    env_file_path = f"/workspace/agent-{agent_id}/.env"
    # 에이전트별 .env 파일 생성
```

---

## 🔧 코드 단순화 가이드라인

### 🚫 피해야 할 복잡성

1. **컨테이너 풀링**: 미리 생성된 컨테이너 관리
2. **동적 리소스 할당**: 에이전트별 메모리/CPU 조정
3. **복잡한 스케줄링**: 에이전트 실행 큐 관리
4. **고급 모니터링**: 실시간 메트릭 수집

### ✅ 유지해야 할 단순성

1. **사용자 연결시 컨테이너 생성/재사용**
2. **에이전트 생성시 디렉토리만 분리**
3. **WebSocket 연결 종료시 컨테이너 정리**
4. **기본적인 로깅과 오류 처리**

---

## 📊 리소스 예측 및 제한

### 현재 설정 (main.py:83-84)
```python
mem_limit="1g",      # 사용자당 1GB 메모리
cpu_count=1,         # 사용자당 1 CPU 코어
```

### 사용자별 에이전트 수 제한
```
권장: 사용자당 최대 10개 에이전트
이유: 
- 메모리 1GB ÷ 10개 = 에이전트당 ~100MB
- 복잡도 관리 가능
- UI에서 표시하기 적절한 수량
```

### 동시 실행 에이전트 제한
```
권장: 사용자당 최대 3개 동시 실행
이유:
- CPU 1코어 ÷ 3개 = 적절한 성능 보장
- Claude API 레이트 리밋 고려
- 사용자 경험 품질 유지
```

---

## 🎯 결론 및 실행 계획

### ✅ 결론: 현재 아키텍처 유지

**"1인 1컨테이너"** 방식은 다음 조건을 모두 만족:
- ✅ 적은 코드
- ✅ 단순한 구조  
- ✅ 충분한 성능
- ✅ 관리 용이성

### 📝 최소한의 개선사항

1. **에이전트별 작업 디렉토리 분리** (3줄 코드 추가)
2. **기본 리소스 모니터링** (5줄 코드 추가)
3. **에이전트 수 제한 체크** (2줄 코드 추가)

### 🚀 구현 우선순위

1. **Phase 1**: 현재 구조 그대로 대시보드 UI 완성
2. **Phase 2**: 에이전트별 디렉토리 분리만 추가
3. **Phase 3**: 기본 제한 및 모니터링 추가

---

## 💻 코드 변경 최소화 예시

```python
# 기존 코드에 3줄만 추가
async def send_to_claude(self, message: str, agent_id: str = None) -> str:
    container = await self.ensure_container()
    
    # 에이전트별 작업 디렉토리 (신규 추가)
    workdir = f"/workspace/agent-{agent_id}" if agent_id else "/workspace"
    Path(workdir).mkdir(exist_ok=True)  # 디렉토리 생성
    
    result = container.exec_run(
        cmd=f"claude --print --dangerously-skip-permissions '{escaped_message}'",
        user='claude',
        workdir=workdir  # 기존: '/workspace' → 변경: workdir
    )
```

이 정도의 **최소한의 변경**으로도 에이전트 간 파일 충돌을 방지하면서 구조의 단순성을 유지할 수 있습니다.

---

**핵심 메시지**: 현재 아키텍처는 요구사항에 최적화되어 있으므로, **과도한 최적화보다는 단순성 유지**에 집중해야 합니다.